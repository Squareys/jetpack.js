require './syntax_def'

def print_title
  puts "/* Generated by Ruby Script! */"
end

class Symbol

  def to_codegen
    if self == :String then
      return "UString"
    elsif self == :Boolean then
      return "bool"
    elsif self == :Number then
      return "double"
    elsif self == :VarKind then
      return "VarKind"
    else
      return "Sp<" + self.to_s + ">"
    end
  end

end


class Array

  def opt_to_codegen(opt)
    "std::optional<#{opt.value.to_codegen}>"
  end

  def to_codegen
    if self.length == 1 and self[0].is_a? Option then
      return "std::vector<#{opt_to_codegen(self[0])}>"
    elsif self.length == 1 and self[0].is_a? Symbol then
      return "std::vector<#{self[0].to_codegen}>"
    end
    super.to_codegen
  end

end

class Option

  def to_codegen
    "std::optional<#{@value.to_codegen}>"
  end

end

class Variant

  def to_codegen
    "std::variant<#{self.str_content}>"
  end

  def str_content
    result = ""
    @elements.each do |item|
      result += item.to_codegen + ", "
    end
    result.slice(0, result.length - 2)
  end

end

class Property


  @@reservec_props = [
    "operator",
    "static",
  ]

  def pretty_name
    result = @name.chars.map do |ch|
      if /[[:upper:]]/.match(ch) then
        ['_', ch.downcase]
      else
        [ch]
      end
    end
    
    result = result.flatten.join('')

    if @@reservec_props.include? result then
      return result + '_'
    end
    result
  end

  def to_codegen
    result = @prop_type.to_codegen + " " + self.pretty_name

    if @prop_type == :Boolean
      result += " = false"
    end

    result
  end

end

$stdout.reopen('src/parser/node_types.h', 'w')

print_title
puts "
#pragma once

enum class SyntaxNodeType {
    Invalid = 0,

"

SyntaxFactory.syntaxes.each do |item|
  if !item.is_virtual then
    puts "    " + item.class_id.to_s + ","
  end
end

puts "
};
"

puts ""
puts "static const char* SyntaxNodeTypeToString(SyntaxNodeType type_);"
puts ""

SyntaxFactory.syntaxes.each do |item|
  if !item.is_virtual then
    puts "class " + item.class_id.to_s + ";"
  end
end

$stdout.reopen('src/parser/syntax_nodes.h', 'w')

print_title
puts '

#pragma once

#include "base_nodes.h"
#include <optional>
#include <vector>
#include <variant>

'

SyntaxFactory.syntaxes.each do |item|
  if !item.is_virtual then
    id = item.class_id.to_s
    base_content = ""

    index = 0
    if item.base.is_a? Array then
      item.base.each do |base_i|
        base_content += "public " + base_i.to_s
        if index != item.base.length - 1 then
          base_content += ", "
        end
        index += 1
      end
    else
      base_content += "public " + item.base.to_s
    end

    puts "
class #{id}: #{base_content} {
public:
    #{id}();

"
  item.props.each do |prop|
    puts "    #{prop.to_codegen};"
  end

  puts "
};
"
  end
end

$stdout.reopen('src/parser/syntax_nodes.cpp', 'w')
print_title
puts '
#include "syntax_nodes.h"
'

SyntaxFactory.syntaxes.each do |item|
  if !item.is_virtual then
    id = item.class_id.to_s

    index = 0
    base_content = ""
    if item.base.is_a? Array then
      item.base.each do |base_i|
        base_content += base_i.to_s + "()"
        if index != item.base.length - 1 then
          base_content += ", "
        end
        index += 1
      end
    else
      base_content += item.base.to_s + "()"
    end

    puts "
#{id}::#{id}(): #{base_content} {
    type = SyntaxNodeType::#{id};
}
"
  end
end

$stdout.reopen('src/parser/node_types.cpp', 'w')
print_title
puts '
#include "node_types.h"

const char* SyntaxNodeTypeToString(SyntaxNodeType type_) {
    switch (type_) {
'

SyntaxFactory.syntaxes.each do |item|
  if !item.is_virtual then
    id = item.class_id.to_s
    puts "
        case SyntaxNodeType::#{id}:
            return \"#{id}\";
"
  end
end

puts '
        default:
            return "<Invalid>";

    }
}
'

$stdout.reopen('src/dumper/ast_to_json.h', 'w')
print_title
puts '
#pragma once

#include <nlohmann/json.hpp>
#include <vector>
#include <memory>
#include <tsl/ordered_map.h>
#include "../utils.h"

namespace dumper {

    template<class Key, class T, class Ignore, class Allocator,
         class Hash = std::hash<Key>, class KeyEqual = std::equal_to<Key>,
         class AllocatorPair = typename std::allocator_traits<Allocator>::template rebind_alloc<std::pair<Key, T>>,
         class ValueTypeContainer = std::vector<std::pair<Key, T>, AllocatorPair>>
    using ordered_map = tsl::ordered_map<Key, T, Hash, KeyEqual, AllocatorPair, ValueTypeContainer>;

    using json = nlohmann::basic_json<ordered_map>;

    template <typename T>
    using Sp = std::shared_ptr<T>;

    class AstToJson {
    public:

        static void DumpBaseInfo(json& result, const Sp<SyntaxNode>& node) {
            result["start"] = node->range.first;
            result["end"] = node->range.second;

            json loc = json::object();

            json start = json::object();
            start["line"] = node->location.start_.line_;
            start["column"] = node->location.start_.column_;
            loc["start"] = start;

            json end = json::object();
            end["line"] = node->location.end_.line_;
            end["column"] = node->location.end_.column_;
            loc["end"] = end;

            result["loc"] = loc;
        }

        static json Dump(const Sp<SyntaxNode>& node) {
            switch (node->type) {'

SyntaxFactory.syntaxes.each do |item|
  if !item.is_virtual then
    id = item.class_id.to_s
    puts "
                case SyntaxNodeType::#{id}: {
                    auto child = std::dynamic_pointer_cast<#{id}>(node);
                    return Dump(child);
                }"

  end
end

puts "
                default:
                    return json::object();

            }
        }
"

SyntaxFactory.syntaxes.each do |item|
  if !item.is_virtual then
    id = item.class_id.to_s
    puts "
        static json Dump(const Sp<#{id}>& node) {
            json result = json::object();
            result[\"type\"] = \"#{id}\";
            DumpBaseInfo(result, node);"

    item.props.each do |item|
      if [:Boolean, :Number, :VarKind].include? item.prop_type then
        puts "            result[\"#{item.name}\"] = node->#{item.pretty_name};"
      elsif item.prop_type == :String then
        puts "            result[\"#{item.name}\"] = utils::To_UTF8(node->#{item.pretty_name});"
      elsif item.prop_type.is_a? Array then
        array_name = "array_#{item.name}"
        puts "            json #{array_name} = json::array();"
        if item.prop_type[0].is_a? Option then
          puts "
            for (auto& i : node->#{item.name}) {
                if (i.has_value()) {
                    #{array_name}.push_back(Dump(*i));
                } else {
                    #{array_name}.push_back(nullptr);
                }
            }"
        else
          puts "
              for (auto& i : node->#{item.name}) {
                  #{array_name}.push_back(Dump(i));
              }"
        end
        puts "            result[\"#{item.name}\"] = std::move(#{array_name});"

      elsif item.prop_type.is_a? Option then
        puts "            if (node->#{item.pretty_name}) {"
        puts "                result[\"#{item.name}\"] = Dump(*node->#{item.pretty_name});"
        puts "            }"
      elsif item.prop_type.is_a? Variant then
        # nothing
        item.prop_type.elements.each do |elem|
          if elem == :String then
            puts "            if (std::holds_alternative<UString>(node->#{item.name})) result[\"#{item.name}\"] = utils::To_UTF8(std::get<UString>(node->#{item.name}));"
          else
            puts "            if (std::holds_alternative<#{elem.to_codegen}>(node->#{item.name})) result[\"#{item.name}\"] = std::get<#{elem.to_codegen}>(node->#{item.name});"
          end
        end
      else
        puts "            result[\"#{item.name}\"] = Dump(node->#{item.pretty_name});"
      end
    end

    puts "
            return result;
        }"

  end
end

puts '
    };
}
'
