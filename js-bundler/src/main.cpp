//
// Created by Duzhong Chen on 2020/3/20.
//

#include <iostream>
#include <cxxopts.hpp>

#include "ModuleResolver.h"

#define OPT_HELP "help"
#define OPT_ENTRY "entry"
#define OPT_PRETTY_PRINT "pretty-print"
#define OPT_TOLERANT "tolerant"
#define OPT_ES_MODULE "es-module"
#define OPT_JSX "jsx"
#define OPT_ANALYZE_MODULE "analyze-module"

using namespace rocket_bundle;

static int AnalyzeModule(const std::string& path);

int main(int argc, char** argv) {
    try {
        cxxopts::Options options("rocket-bundle", "Rocket Bundle command line");
        options.add_options()
                (OPT_ENTRY, "entry file to parse", cxxopts::value<std::string>())
                (OPT_PRETTY_PRINT, "print the code generated by bundler")
                (OPT_TOLERANT, "tolerant parsing error")
                (OPT_ES_MODULE, "parsing as ES module")
                (OPT_JSX, "support jsx syntax")
                (OPT_HELP, "produce help message")
                (OPT_ANALYZE_MODULE, "analyze a module and print result", cxxopts::value<std::string>())
                ;

        options.parse_positional(OPT_ENTRY);

        auto result = options.parse(argc, argv);

        // print help message
        if (result[OPT_HELP].count()) {
            std::cout << options.help() << std::endl;
            return !result[OPT_HELP].count();
        }

        if (result[OPT_ANALYZE_MODULE].count()) {
            std::string path = result[OPT_ANALYZE_MODULE].as<std::string>();
            return AnalyzeModule(path);
        }

        std::cout << options.help() << std::endl;
        return 0;
    } catch (std::exception& ex) {
        std::cerr << ex.what() << std::endl;
        return 1;
    }
}

static int AnalyzeModule(const std::string& path) {
    auto resolver = std::make_shared<ModuleResolver>();
    resolver->SetTraceFile(false);
    resolver->BeginFromEntry(path);
    resolver->PrintStatistic();
    return 0;
}
