#include <iostream>
#include <fstream>
#include <string>
#include <chrono>

#include <cxxopts.hpp>

#include "../codegen/codegen.h"
#include "../parser/parser.hpp"
#include "../dumper/ast_to_json.h"
#include "../artery.h"

using namespace parser;

#define OPT_HELP "help"
#define OPT_ENTRY "entry"
#define OPT_PRETTY_PRINT "pretty-print"
#define OPT_TOLERANT "tolerant"
#define OPT_ES_MODULE "es-module"
#define OPT_JSX "jsx"

int main(int argc, char** argv) {
    try {
        cxxopts::Options options("zep-cli", "Zhong's ECMAScript Parser CommandLine");
        options.add_options()
            (OPT_ENTRY, "entry file to parse", cxxopts::value<std::string>())
            (OPT_PRETTY_PRINT, "print the code generated by bundler")
            (OPT_TOLERANT, "tolerant parsing error")
            (OPT_ES_MODULE, "parsing as ES module")
            (OPT_JSX, "support jsx syntax")
            (OPT_HELP, "produce help message")
        ;

        options.parse_positional(OPT_ENTRY);

        auto result = options.parse(argc, argv);

//        po::options_description desc("Allowed options");
//        desc.add_options()
//            (OPT_ENTRY, "entry file to parse")
//            (OPT_PRETTY_PRINT, "print the code generated by bundler")
//            (OPT_TOLERANT, "tolerant parsing error")
//            (OPT_ES_MODULE, "parsing as ES module")
//            (OPT_JSX, "support jsx syntax")
//            (OPT_HELP, "produce help message")
//            ;
//
//        po::positional_options_description p;
//        p.add(OPT_ENTRY, 1);
//
//        po::variables_map vm;
//        po::store(po::command_line_parser(argc, argv)
//            .options(desc).positional(p).run(), vm);
//        po::notify(vm);

        if (result[OPT_HELP].count() || !result[OPT_ENTRY].count()) {
            std::cout << options.help() << std::endl;
            return !result[OPT_HELP].count();
        }

        if (result[OPT_ENTRY].count()) {
            std::cout << "has entry" << std::endl;
        }
        auto entry_file = result[OPT_ENTRY].as<std::string>();

        auto src = make_shared<UString>();

        (*src) = Artery::ReadFileStream(entry_file);

        auto start = std::chrono::system_clock::now();

        for (int i = 0; i < 5; i++) {
            ParserCommon::Config config = ParserCommon::Config::Default();
            config.tolerant = result[OPT_TOLERANT].count();
            config.jsx = result[OPT_JSX].count();

            Parser parser(src, config);
            if (result[OPT_ES_MODULE].count()) {
                auto module = parser.ParseModule();

                if (result[OPT_PRETTY_PRINT].count()) {
                    CodeGen codegen;
                    codegen.TraverseNode(module);
                } else {
                    auto json_result = dumper::AstToJson::Dump(module);
                    std::cout << json_result.dump(2) << std::endl;
                }
            } else {
                auto script = parser.ParseScript();

//                if (result[OPT_PRETTY_PRINT].count()) {
//                    CodeGen codegen;
//                    codegen.TraverseNode(script);
//                } else {
//                    auto json_result = dumper::AstToJson::Dump(script);
//                    std::cout << json_result.dump(2) << std::endl;
//                }
            }

        }
        auto end = std::chrono::system_clock::now();

        std::chrono::duration<double> elapsed_seconds = end-start;
        std::time_t end_time = std::chrono::system_clock::to_time_t(end);

        std::cout << "finished computation at " << std::ctime(&end_time)
                  << "elapsed time: " << elapsed_seconds.count() << "s\n";
    } catch (ParseError& err) {
        std::cerr << err.ErrorMessage() << std::endl;
        return 1;
    } catch (std::exception& ex) {
        std::cerr << ex.what() << std::endl;
        return 1;
    }
    return 0;
}
