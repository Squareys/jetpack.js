/* Generated by Ruby Script! */

#pragma once

#include <nlohmann/json.hpp>
#include <vector>
#include <memory>
#include <tsl/ordered_map.h>
#include "../utils.h"

namespace dumper {

    template<class Key, class T, class Ignore, class Allocator,
         class Hash = std::hash<Key>, class KeyEqual = std::equal_to<Key>,
         class AllocatorPair = typename std::allocator_traits<Allocator>::template rebind_alloc<std::pair<Key, T>>,
         class ValueTypeContainer = std::vector<std::pair<Key, T>, AllocatorPair>>
    using ordered_map = tsl::ordered_map<Key, T, Hash, KeyEqual, AllocatorPair, ValueTypeContainer>;

    using json = nlohmann::basic_json<ordered_map>;

    template <typename T>
    using Sp = std::shared_ptr<T>;

    class AstToJson {
    public:

        static void DumpBaseInfo(json& result, const Sp<SyntaxNode>& node) {
            result["start"] = node->range.first;
            result["end"] = node->range.second;

            json loc = json::object();

            json start = json::object();
            start["line"] = node->location.start_.line_;
            start["column"] = node->location.start_.column_;
            loc["start"] = start;

            json end = json::object();
            end["line"] = node->location.end_.line_;
            end["column"] = node->location.end_.column_;
            loc["end"] = end;

            result["loc"] = loc;
        }

        static json Dump(const Sp<SyntaxNode>& node) {
            switch (node->type) {

                case SyntaxNodeType::ArrayExpression: {
                    auto child = std::dynamic_pointer_cast<ArrayExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrayPattern: {
                    auto child = std::dynamic_pointer_cast<ArrayPattern>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrowFunctionExpression: {
                    auto child = std::dynamic_pointer_cast<ArrowFunctionExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AssignmentExpression: {
                    auto child = std::dynamic_pointer_cast<AssignmentExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AssignmentPattern: {
                    auto child = std::dynamic_pointer_cast<AssignmentPattern>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AwaitExpression: {
                    auto child = std::dynamic_pointer_cast<AwaitExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BinaryExpression: {
                    auto child = std::dynamic_pointer_cast<BinaryExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BlockStatement: {
                    auto child = std::dynamic_pointer_cast<BlockStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BreakStatement: {
                    auto child = std::dynamic_pointer_cast<BreakStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::CallExpression: {
                    auto child = std::dynamic_pointer_cast<CallExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::CatchClause: {
                    auto child = std::dynamic_pointer_cast<CatchClause>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassBody: {
                    auto child = std::dynamic_pointer_cast<ClassBody>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassDeclaration: {
                    auto child = std::dynamic_pointer_cast<ClassDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassExpression: {
                    auto child = std::dynamic_pointer_cast<ClassExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ConditionalExpression: {
                    auto child = std::dynamic_pointer_cast<ConditionalExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ContinueStatement: {
                    auto child = std::dynamic_pointer_cast<ContinueStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::DebuggerStatement: {
                    auto child = std::dynamic_pointer_cast<DebuggerStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Directive: {
                    auto child = std::dynamic_pointer_cast<Directive>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::DoWhileStatement: {
                    auto child = std::dynamic_pointer_cast<DoWhileStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::EmptyStatement: {
                    auto child = std::dynamic_pointer_cast<EmptyStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportAllDeclaration: {
                    auto child = std::dynamic_pointer_cast<ExportAllDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportDefaultDeclaration: {
                    auto child = std::dynamic_pointer_cast<ExportDefaultDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportNamedDeclaration: {
                    auto child = std::dynamic_pointer_cast<ExportNamedDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportSpecifier: {
                    auto child = std::dynamic_pointer_cast<ExportSpecifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExpressionStatement: {
                    auto child = std::dynamic_pointer_cast<ExpressionStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForInStatement: {
                    auto child = std::dynamic_pointer_cast<ForInStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForOfStatement: {
                    auto child = std::dynamic_pointer_cast<ForOfStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForStatement: {
                    auto child = std::dynamic_pointer_cast<ForStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::FunctionDeclaration: {
                    auto child = std::dynamic_pointer_cast<FunctionDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::FunctionExpression: {
                    auto child = std::dynamic_pointer_cast<FunctionExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Identifier: {
                    auto child = std::dynamic_pointer_cast<Identifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::IfStatement: {
                    auto child = std::dynamic_pointer_cast<IfStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Import: {
                    auto child = std::dynamic_pointer_cast<Import>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportDeclaration: {
                    auto child = std::dynamic_pointer_cast<ImportDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportDefaultSpecifier: {
                    auto child = std::dynamic_pointer_cast<ImportDefaultSpecifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportNamespaceSpecifier: {
                    auto child = std::dynamic_pointer_cast<ImportNamespaceSpecifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportSpecifier: {
                    auto child = std::dynamic_pointer_cast<ImportSpecifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::LabeledStatement: {
                    auto child = std::dynamic_pointer_cast<LabeledStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Literal: {
                    auto child = std::dynamic_pointer_cast<Literal>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MetaProperty: {
                    auto child = std::dynamic_pointer_cast<MetaProperty>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MethodDefinition: {
                    auto child = std::dynamic_pointer_cast<MethodDefinition>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Module: {
                    auto child = std::dynamic_pointer_cast<Module>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::NewExpression: {
                    auto child = std::dynamic_pointer_cast<NewExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ObjectExpression: {
                    auto child = std::dynamic_pointer_cast<ObjectExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ObjectPattern: {
                    auto child = std::dynamic_pointer_cast<ObjectPattern>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Property: {
                    auto child = std::dynamic_pointer_cast<Property>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::RegexLiteral: {
                    auto child = std::dynamic_pointer_cast<RegexLiteral>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::RestElement: {
                    auto child = std::dynamic_pointer_cast<RestElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ReturnStatement: {
                    auto child = std::dynamic_pointer_cast<ReturnStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Script: {
                    auto child = std::dynamic_pointer_cast<Script>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SequenceExpression: {
                    auto child = std::dynamic_pointer_cast<SequenceExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SpreadElement: {
                    auto child = std::dynamic_pointer_cast<SpreadElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MemberExpression: {
                    auto child = std::dynamic_pointer_cast<MemberExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Super: {
                    auto child = std::dynamic_pointer_cast<Super>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SwitchCase: {
                    auto child = std::dynamic_pointer_cast<SwitchCase>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SwitchStatement: {
                    auto child = std::dynamic_pointer_cast<SwitchStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TaggedTemplateExpression: {
                    auto child = std::dynamic_pointer_cast<TaggedTemplateExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TemplateElement: {
                    auto child = std::dynamic_pointer_cast<TemplateElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TemplateLiteral: {
                    auto child = std::dynamic_pointer_cast<TemplateLiteral>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ThisExpression: {
                    auto child = std::dynamic_pointer_cast<ThisExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ThrowStatement: {
                    auto child = std::dynamic_pointer_cast<ThrowStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TryStatement: {
                    auto child = std::dynamic_pointer_cast<TryStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::UnaryExpression: {
                    auto child = std::dynamic_pointer_cast<UnaryExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::UpdateExpression: {
                    auto child = std::dynamic_pointer_cast<UpdateExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::VariableDeclaration: {
                    auto child = std::dynamic_pointer_cast<VariableDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::VariableDeclarator: {
                    auto child = std::dynamic_pointer_cast<VariableDeclarator>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::WhileStatement: {
                    auto child = std::dynamic_pointer_cast<WhileStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::WithStatement: {
                    auto child = std::dynamic_pointer_cast<WithStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::YieldExpression: {
                    auto child = std::dynamic_pointer_cast<YieldExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrowParameterPlaceHolder: {
                    auto child = std::dynamic_pointer_cast<ArrowParameterPlaceHolder>(node);
                    return Dump(child);
                }

                default:
                    return json::object();

            }
        }

        static json Dump(const Sp<ArrayExpression>& node) {
            json result = json::object();
            result["type"] = "ArrayExpression";
            DumpBaseInfo(result, node);
            json array_elements = json::array();

            for (auto& i : node->elements) {
                if (i.has_value()) {
                    array_elements.push_back(Dump(*i));
                } else {
                    array_elements.push_back(nullptr);
                }
            }
            result["elements"] = std::move(array_elements);

            return result;
        }

        static json Dump(const Sp<ArrayPattern>& node) {
            json result = json::object();
            result["type"] = "ArrayPattern";
            DumpBaseInfo(result, node);
            json array_elements = json::array();

            for (auto& i : node->elements) {
                if (i.has_value()) {
                    array_elements.push_back(Dump(*i));
                } else {
                    array_elements.push_back(nullptr);
                }
            }
            result["elements"] = std::move(array_elements);

            return result;
        }

        static json Dump(const Sp<ArrowFunctionExpression>& node) {
            json result = json::object();
            result["type"] = "ArrowFunctionExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(const Sp<AssignmentExpression>& node) {
            json result = json::object();
            result["type"] = "AssignmentExpression";
            DumpBaseInfo(result, node);
            result["operator"] = utils::To_UTF8(node->operator_);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(const Sp<AssignmentPattern>& node) {
            json result = json::object();
            result["type"] = "AssignmentPattern";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(const Sp<AwaitExpression>& node) {
            json result = json::object();
            result["type"] = "AwaitExpression";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<BinaryExpression>& node) {
            json result = json::object();
            result["type"] = "BinaryExpression";
            DumpBaseInfo(result, node);
            result["operator"] = utils::To_UTF8(node->operator_);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(const Sp<BlockStatement>& node) {
            json result = json::object();
            result["type"] = "BlockStatement";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);

            return result;
        }

        static json Dump(const Sp<BreakStatement>& node) {
            json result = json::object();
            result["type"] = "BreakStatement";
            DumpBaseInfo(result, node);
            if (node->label) {
                result["label"] = Dump(*node->label);
            }

            return result;
        }

        static json Dump(const Sp<CallExpression>& node) {
            json result = json::object();
            result["type"] = "CallExpression";
            DumpBaseInfo(result, node);
            result["callee"] = Dump(node->callee);
            json array_arguments = json::array();

              for (auto& i : node->arguments) {
                  array_arguments.push_back(Dump(i));
              }
            result["arguments"] = std::move(array_arguments);

            return result;
        }

        static json Dump(const Sp<CatchClause>& node) {
            json result = json::object();
            result["type"] = "CatchClause";
            DumpBaseInfo(result, node);
            result["param"] = Dump(node->param);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<ClassBody>& node) {
            json result = json::object();
            result["type"] = "ClassBody";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);

            return result;
        }

        static json Dump(const Sp<ClassDeclaration>& node) {
            json result = json::object();
            result["type"] = "ClassDeclaration";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            if (node->super_class) {
                result["superClass"] = Dump(*node->super_class);
            }
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<ClassExpression>& node) {
            json result = json::object();
            result["type"] = "ClassExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            if (node->super_class) {
                result["superClass"] = Dump(*node->super_class);
            }
            if (node->body) {
                result["body"] = Dump(*node->body);
            }

            return result;
        }

        static json Dump(const Sp<ConditionalExpression>& node) {
            json result = json::object();
            result["type"] = "ConditionalExpression";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["consequent"] = Dump(node->consequent);
            result["alternate"] = Dump(node->alternate);

            return result;
        }

        static json Dump(const Sp<ContinueStatement>& node) {
            json result = json::object();
            result["type"] = "ContinueStatement";
            DumpBaseInfo(result, node);
            if (node->label) {
                result["label"] = Dump(*node->label);
            }

            return result;
        }

        static json Dump(const Sp<DebuggerStatement>& node) {
            json result = json::object();
            result["type"] = "DebuggerStatement";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<Directive>& node) {
            json result = json::object();
            result["type"] = "Directive";
            DumpBaseInfo(result, node);
            result["expression"] = Dump(node->expression);
            result["directive"] = utils::To_UTF8(node->directive);

            return result;
        }

        static json Dump(const Sp<DoWhileStatement>& node) {
            json result = json::object();
            result["type"] = "DoWhileStatement";
            DumpBaseInfo(result, node);
            result["body"] = Dump(node->body);
            result["test"] = Dump(node->test);

            return result;
        }

        static json Dump(const Sp<EmptyStatement>& node) {
            json result = json::object();
            result["type"] = "EmptyStatement";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<ExportAllDeclaration>& node) {
            json result = json::object();
            result["type"] = "ExportAllDeclaration";
            DumpBaseInfo(result, node);
            result["source"] = Dump(node->source);

            return result;
        }

        static json Dump(const Sp<ExportDefaultDeclaration>& node) {
            json result = json::object();
            result["type"] = "ExportDefaultDeclaration";
            DumpBaseInfo(result, node);
            result["declaration"] = Dump(node->declaration);

            return result;
        }

        static json Dump(const Sp<ExportNamedDeclaration>& node) {
            json result = json::object();
            result["type"] = "ExportNamedDeclaration";
            DumpBaseInfo(result, node);
            if (node->declaration) {
                result["declaration"] = Dump(*node->declaration);
            }
            json array_specifiers = json::array();

              for (auto& i : node->specifiers) {
                  array_specifiers.push_back(Dump(i));
              }
            result["specifiers"] = std::move(array_specifiers);
            if (node->source) {
                result["source"] = Dump(*node->source);
            }

            return result;
        }

        static json Dump(const Sp<ExportSpecifier>& node) {
            json result = json::object();
            result["type"] = "ExportSpecifier";
            DumpBaseInfo(result, node);
            result["exported"] = Dump(node->exported);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(const Sp<ExpressionStatement>& node) {
            json result = json::object();
            result["type"] = "ExpressionStatement";
            DumpBaseInfo(result, node);
            result["expression"] = Dump(node->expression);

            return result;
        }

        static json Dump(const Sp<ForInStatement>& node) {
            json result = json::object();
            result["type"] = "ForInStatement";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);
            result["body"] = Dump(node->body);
            result["each"] = node->each;

            return result;
        }

        static json Dump(const Sp<ForOfStatement>& node) {
            json result = json::object();
            result["type"] = "ForOfStatement";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<ForStatement>& node) {
            json result = json::object();
            result["type"] = "ForStatement";
            DumpBaseInfo(result, node);
            if (node->init) {
                result["init"] = Dump(*node->init);
            }
            if (node->test) {
                result["test"] = Dump(*node->test);
            }
            if (node->update) {
                result["update"] = Dump(*node->update);
            }
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<FunctionDeclaration>& node) {
            json result = json::object();
            result["type"] = "FunctionDeclaration";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(const Sp<FunctionExpression>& node) {
            json result = json::object();
            result["type"] = "FunctionExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(const Sp<Identifier>& node) {
            json result = json::object();
            result["type"] = "Identifier";
            DumpBaseInfo(result, node);
            result["name"] = utils::To_UTF8(node->name);

            return result;
        }

        static json Dump(const Sp<IfStatement>& node) {
            json result = json::object();
            result["type"] = "IfStatement";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["consequent"] = Dump(node->consequent);
            if (node->alternate) {
                result["alternate"] = Dump(*node->alternate);
            }

            return result;
        }

        static json Dump(const Sp<Import>& node) {
            json result = json::object();
            result["type"] = "Import";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<ImportDeclaration>& node) {
            json result = json::object();
            result["type"] = "ImportDeclaration";
            DumpBaseInfo(result, node);
            json array_specifiers = json::array();

              for (auto& i : node->specifiers) {
                  array_specifiers.push_back(Dump(i));
              }
            result["specifiers"] = std::move(array_specifiers);
            result["source"] = Dump(node->source);

            return result;
        }

        static json Dump(const Sp<ImportDefaultSpecifier>& node) {
            json result = json::object();
            result["type"] = "ImportDefaultSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(const Sp<ImportNamespaceSpecifier>& node) {
            json result = json::object();
            result["type"] = "ImportNamespaceSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(const Sp<ImportSpecifier>& node) {
            json result = json::object();
            result["type"] = "ImportSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);
            result["imported"] = Dump(node->imported);

            return result;
        }

        static json Dump(const Sp<LabeledStatement>& node) {
            json result = json::object();
            result["type"] = "LabeledStatement";
            DumpBaseInfo(result, node);
            result["label"] = Dump(node->label);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<Literal>& node) {
            json result = json::object();
            result["type"] = "Literal";
            DumpBaseInfo(result, node);
            if (std::holds_alternative<bool>(node->value)) result["value"] = std::get<bool>(node->value);
            if (std::holds_alternative<double>(node->value)) result["value"] = std::get<double>(node->value);
            if (std::holds_alternative<UString>(node->value)) result["value"] = utils::To_UTF8(std::get<UString>(node->value));
            result["raw"] = utils::To_UTF8(node->raw);

            return result;
        }

        static json Dump(const Sp<MetaProperty>& node) {
            json result = json::object();
            result["type"] = "MetaProperty";
            DumpBaseInfo(result, node);
            result["meta"] = Dump(node->meta);
            result["property"] = Dump(node->property);

            return result;
        }

        static json Dump(const Sp<MethodDefinition>& node) {
            json result = json::object();
            result["type"] = "MethodDefinition";
            DumpBaseInfo(result, node);
            if (node->key) {
                result["key"] = Dump(*node->key);
            }
            result["computed"] = node->computed;
            if (node->value) {
                result["value"] = Dump(*node->value);
            }
            result["kind"] = node->kind;
            result["static"] = node->static_;

            return result;
        }

        static json Dump(const Sp<Module>& node) {
            json result = json::object();
            result["type"] = "Module";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);
            result["sourceType"] = utils::To_UTF8(node->source_type);

            return result;
        }

        static json Dump(const Sp<NewExpression>& node) {
            json result = json::object();
            result["type"] = "NewExpression";
            DumpBaseInfo(result, node);
            result["callee"] = Dump(node->callee);
            json array_arguments = json::array();

              for (auto& i : node->arguments) {
                  array_arguments.push_back(Dump(i));
              }
            result["arguments"] = std::move(array_arguments);

            return result;
        }

        static json Dump(const Sp<ObjectExpression>& node) {
            json result = json::object();
            result["type"] = "ObjectExpression";
            DumpBaseInfo(result, node);
            json array_properties = json::array();

              for (auto& i : node->properties) {
                  array_properties.push_back(Dump(i));
              }
            result["properties"] = std::move(array_properties);

            return result;
        }

        static json Dump(const Sp<ObjectPattern>& node) {
            json result = json::object();
            result["type"] = "ObjectPattern";
            DumpBaseInfo(result, node);
            json array_properties = json::array();

              for (auto& i : node->properties) {
                  array_properties.push_back(Dump(i));
              }
            result["properties"] = std::move(array_properties);

            return result;
        }

        static json Dump(const Sp<Property>& node) {
            json result = json::object();
            result["type"] = "Property";
            DumpBaseInfo(result, node);
            result["key"] = Dump(node->key);
            result["computed"] = node->computed;
            if (node->value) {
                result["value"] = Dump(*node->value);
            }
            result["kind"] = node->kind;
            result["method"] = node->method;
            result["shorthand"] = node->shorthand;

            return result;
        }

        static json Dump(const Sp<RegexLiteral>& node) {
            json result = json::object();
            result["type"] = "RegexLiteral";
            DumpBaseInfo(result, node);
            result["value"] = utils::To_UTF8(node->value);
            result["raw"] = utils::To_UTF8(node->raw);

            return result;
        }

        static json Dump(const Sp<RestElement>& node) {
            json result = json::object();
            result["type"] = "RestElement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<ReturnStatement>& node) {
            json result = json::object();
            result["type"] = "ReturnStatement";
            DumpBaseInfo(result, node);
            if (node->argument) {
                result["argument"] = Dump(*node->argument);
            }

            return result;
        }

        static json Dump(const Sp<Script>& node) {
            json result = json::object();
            result["type"] = "Script";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);
            result["sourceType"] = utils::To_UTF8(node->source_type);

            return result;
        }

        static json Dump(const Sp<SequenceExpression>& node) {
            json result = json::object();
            result["type"] = "SequenceExpression";
            DumpBaseInfo(result, node);
            json array_expressions = json::array();

              for (auto& i : node->expressions) {
                  array_expressions.push_back(Dump(i));
              }
            result["expressions"] = std::move(array_expressions);

            return result;
        }

        static json Dump(const Sp<SpreadElement>& node) {
            json result = json::object();
            result["type"] = "SpreadElement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<MemberExpression>& node) {
            json result = json::object();
            result["type"] = "MemberExpression";
            DumpBaseInfo(result, node);
            result["computed"] = node->computed;
            result["object"] = Dump(node->object);
            result["property"] = Dump(node->property);

            return result;
        }

        static json Dump(const Sp<Super>& node) {
            json result = json::object();
            result["type"] = "Super";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<SwitchCase>& node) {
            json result = json::object();
            result["type"] = "SwitchCase";
            DumpBaseInfo(result, node);
            if (node->test) {
                result["test"] = Dump(*node->test);
            }
            json array_consequent = json::array();

              for (auto& i : node->consequent) {
                  array_consequent.push_back(Dump(i));
              }
            result["consequent"] = std::move(array_consequent);

            return result;
        }

        static json Dump(const Sp<SwitchStatement>& node) {
            json result = json::object();
            result["type"] = "SwitchStatement";
            DumpBaseInfo(result, node);
            result["discrimiant"] = Dump(node->discrimiant);
            json array_cases = json::array();

              for (auto& i : node->cases) {
                  array_cases.push_back(Dump(i));
              }
            result["cases"] = std::move(array_cases);

            return result;
        }

        static json Dump(const Sp<TaggedTemplateExpression>& node) {
            json result = json::object();
            result["type"] = "TaggedTemplateExpression";
            DumpBaseInfo(result, node);
            result["tag"] = Dump(node->tag);
            result["quasi"] = Dump(node->quasi);

            return result;
        }

        static json Dump(const Sp<TemplateElement>& node) {
            json result = json::object();
            result["type"] = "TemplateElement";
            DumpBaseInfo(result, node);
            result["cooked"] = utils::To_UTF8(node->cooked);
            result["raw"] = utils::To_UTF8(node->raw);
            result["tail"] = node->tail;

            return result;
        }

        static json Dump(const Sp<TemplateLiteral>& node) {
            json result = json::object();
            result["type"] = "TemplateLiteral";
            DumpBaseInfo(result, node);
            json array_quasis = json::array();

              for (auto& i : node->quasis) {
                  array_quasis.push_back(Dump(i));
              }
            result["quasis"] = std::move(array_quasis);
            json array_expressions = json::array();

              for (auto& i : node->expressions) {
                  array_expressions.push_back(Dump(i));
              }
            result["expressions"] = std::move(array_expressions);

            return result;
        }

        static json Dump(const Sp<ThisExpression>& node) {
            json result = json::object();
            result["type"] = "ThisExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<ThrowStatement>& node) {
            json result = json::object();
            result["type"] = "ThrowStatement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<TryStatement>& node) {
            json result = json::object();
            result["type"] = "TryStatement";
            DumpBaseInfo(result, node);
            result["block"] = Dump(node->block);
            if (node->handler) {
                result["handler"] = Dump(*node->handler);
            }
            if (node->finalizer) {
                result["finalizer"] = Dump(*node->finalizer);
            }

            return result;
        }

        static json Dump(const Sp<UnaryExpression>& node) {
            json result = json::object();
            result["type"] = "UnaryExpression";
            DumpBaseInfo(result, node);
            result["operator"] = utils::To_UTF8(node->operator_);
            result["argument"] = Dump(node->argument);
            result["prefix"] = node->prefix;

            return result;
        }

        static json Dump(const Sp<UpdateExpression>& node) {
            json result = json::object();
            result["type"] = "UpdateExpression";
            DumpBaseInfo(result, node);
            result["operator"] = utils::To_UTF8(node->operator_);
            result["argument"] = Dump(node->argument);
            result["prefix"] = node->prefix;

            return result;
        }

        static json Dump(const Sp<VariableDeclaration>& node) {
            json result = json::object();
            result["type"] = "VariableDeclaration";
            DumpBaseInfo(result, node);
            json array_declarations = json::array();

              for (auto& i : node->declarations) {
                  array_declarations.push_back(Dump(i));
              }
            result["declarations"] = std::move(array_declarations);
            result["kind"] = node->kind;

            return result;
        }

        static json Dump(const Sp<VariableDeclarator>& node) {
            json result = json::object();
            result["type"] = "VariableDeclarator";
            DumpBaseInfo(result, node);
            result["id"] = Dump(node->id);
            if (node->init) {
                result["init"] = Dump(*node->init);
            }

            return result;
        }

        static json Dump(const Sp<WhileStatement>& node) {
            json result = json::object();
            result["type"] = "WhileStatement";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<WithStatement>& node) {
            json result = json::object();
            result["type"] = "WithStatement";
            DumpBaseInfo(result, node);
            result["object"] = Dump(node->object);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<YieldExpression>& node) {
            json result = json::object();
            result["type"] = "YieldExpression";
            DumpBaseInfo(result, node);
            if (node->argument) {
                result["argument"] = Dump(*node->argument);
            }
            result["delegate"] = node->delegate;

            return result;
        }

        static json Dump(const Sp<ArrowParameterPlaceHolder>& node) {
            json result = json::object();
            result["type"] = "ArrowParameterPlaceHolder";
            DumpBaseInfo(result, node);
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["async"] = node->async;

            return result;
        }

    };
}
