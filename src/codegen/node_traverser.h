/* Generated by Ruby Script! */


#pragma once
#include "../parser/syntax_nodes.h"

class AutoNodeTraverser {
public:

  AutoNodeTraverser() = default;
    
    void TraverseNode(const Sp<SyntaxNode>& node);

    virtual bool TraverseBefore(const Sp<ArrayExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<ArrayExpression>& node) {}
    virtual bool TraverseBefore(const Sp<ArrayPattern>& node) { return true; }
    virtual void TraverseAfter(const Sp<ArrayPattern>& node) {}
    virtual bool TraverseBefore(const Sp<ArrowFunctionExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<ArrowFunctionExpression>& node) {}
    virtual bool TraverseBefore(const Sp<AssignmentExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<AssignmentExpression>& node) {}
    virtual bool TraverseBefore(const Sp<AssignmentPattern>& node) { return true; }
    virtual void TraverseAfter(const Sp<AssignmentPattern>& node) {}
    virtual bool TraverseBefore(const Sp<AwaitExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<AwaitExpression>& node) {}
    virtual bool TraverseBefore(const Sp<BinaryExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<BinaryExpression>& node) {}
    virtual bool TraverseBefore(const Sp<BlockStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<BlockStatement>& node) {}
    virtual bool TraverseBefore(const Sp<BreakStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<BreakStatement>& node) {}
    virtual bool TraverseBefore(const Sp<CallExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<CallExpression>& node) {}
    virtual bool TraverseBefore(const Sp<CatchClause>& node) { return true; }
    virtual void TraverseAfter(const Sp<CatchClause>& node) {}
    virtual bool TraverseBefore(const Sp<ClassBody>& node) { return true; }
    virtual void TraverseAfter(const Sp<ClassBody>& node) {}
    virtual bool TraverseBefore(const Sp<ClassDeclaration>& node) { return true; }
    virtual void TraverseAfter(const Sp<ClassDeclaration>& node) {}
    virtual bool TraverseBefore(const Sp<ClassExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<ClassExpression>& node) {}
    virtual bool TraverseBefore(const Sp<ConditionalExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<ConditionalExpression>& node) {}
    virtual bool TraverseBefore(const Sp<ContinueStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<ContinueStatement>& node) {}
    virtual bool TraverseBefore(const Sp<DebuggerStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<DebuggerStatement>& node) {}
    virtual bool TraverseBefore(const Sp<Directive>& node) { return true; }
    virtual void TraverseAfter(const Sp<Directive>& node) {}
    virtual bool TraverseBefore(const Sp<DoWhileStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<DoWhileStatement>& node) {}
    virtual bool TraverseBefore(const Sp<EmptyStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<EmptyStatement>& node) {}
    virtual bool TraverseBefore(const Sp<ExportAllDeclaration>& node) { return true; }
    virtual void TraverseAfter(const Sp<ExportAllDeclaration>& node) {}
    virtual bool TraverseBefore(const Sp<ExportDefaultDeclaration>& node) { return true; }
    virtual void TraverseAfter(const Sp<ExportDefaultDeclaration>& node) {}
    virtual bool TraverseBefore(const Sp<ExportNamedDeclaration>& node) { return true; }
    virtual void TraverseAfter(const Sp<ExportNamedDeclaration>& node) {}
    virtual bool TraverseBefore(const Sp<ExportSpecifier>& node) { return true; }
    virtual void TraverseAfter(const Sp<ExportSpecifier>& node) {}
    virtual bool TraverseBefore(const Sp<ExpressionStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<ExpressionStatement>& node) {}
    virtual bool TraverseBefore(const Sp<ForInStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<ForInStatement>& node) {}
    virtual bool TraverseBefore(const Sp<ForOfStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<ForOfStatement>& node) {}
    virtual bool TraverseBefore(const Sp<ForStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<ForStatement>& node) {}
    virtual bool TraverseBefore(const Sp<FunctionDeclaration>& node) { return true; }
    virtual void TraverseAfter(const Sp<FunctionDeclaration>& node) {}
    virtual bool TraverseBefore(const Sp<FunctionExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<FunctionExpression>& node) {}
    virtual bool TraverseBefore(const Sp<Identifier>& node) { return true; }
    virtual void TraverseAfter(const Sp<Identifier>& node) {}
    virtual bool TraverseBefore(const Sp<IfStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<IfStatement>& node) {}
    virtual bool TraverseBefore(const Sp<Import>& node) { return true; }
    virtual void TraverseAfter(const Sp<Import>& node) {}
    virtual bool TraverseBefore(const Sp<ImportDeclaration>& node) { return true; }
    virtual void TraverseAfter(const Sp<ImportDeclaration>& node) {}
    virtual bool TraverseBefore(const Sp<ImportDefaultSpecifier>& node) { return true; }
    virtual void TraverseAfter(const Sp<ImportDefaultSpecifier>& node) {}
    virtual bool TraverseBefore(const Sp<ImportNamespaceSpecifier>& node) { return true; }
    virtual void TraverseAfter(const Sp<ImportNamespaceSpecifier>& node) {}
    virtual bool TraverseBefore(const Sp<ImportSpecifier>& node) { return true; }
    virtual void TraverseAfter(const Sp<ImportSpecifier>& node) {}
    virtual bool TraverseBefore(const Sp<LabeledStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<LabeledStatement>& node) {}
    virtual bool TraverseBefore(const Sp<Literal>& node) { return true; }
    virtual void TraverseAfter(const Sp<Literal>& node) {}
    virtual bool TraverseBefore(const Sp<MetaProperty>& node) { return true; }
    virtual void TraverseAfter(const Sp<MetaProperty>& node) {}
    virtual bool TraverseBefore(const Sp<MethodDefinition>& node) { return true; }
    virtual void TraverseAfter(const Sp<MethodDefinition>& node) {}
    virtual bool TraverseBefore(const Sp<Module>& node) { return true; }
    virtual void TraverseAfter(const Sp<Module>& node) {}
    virtual bool TraverseBefore(const Sp<NewExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<NewExpression>& node) {}
    virtual bool TraverseBefore(const Sp<ObjectExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<ObjectExpression>& node) {}
    virtual bool TraverseBefore(const Sp<ObjectPattern>& node) { return true; }
    virtual void TraverseAfter(const Sp<ObjectPattern>& node) {}
    virtual bool TraverseBefore(const Sp<Property>& node) { return true; }
    virtual void TraverseAfter(const Sp<Property>& node) {}
    virtual bool TraverseBefore(const Sp<RegexLiteral>& node) { return true; }
    virtual void TraverseAfter(const Sp<RegexLiteral>& node) {}
    virtual bool TraverseBefore(const Sp<RestElement>& node) { return true; }
    virtual void TraverseAfter(const Sp<RestElement>& node) {}
    virtual bool TraverseBefore(const Sp<ReturnStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<ReturnStatement>& node) {}
    virtual bool TraverseBefore(const Sp<Script>& node) { return true; }
    virtual void TraverseAfter(const Sp<Script>& node) {}
    virtual bool TraverseBefore(const Sp<SequenceExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<SequenceExpression>& node) {}
    virtual bool TraverseBefore(const Sp<SpreadElement>& node) { return true; }
    virtual void TraverseAfter(const Sp<SpreadElement>& node) {}
    virtual bool TraverseBefore(const Sp<MemberExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<MemberExpression>& node) {}
    virtual bool TraverseBefore(const Sp<Super>& node) { return true; }
    virtual void TraverseAfter(const Sp<Super>& node) {}
    virtual bool TraverseBefore(const Sp<SwitchCase>& node) { return true; }
    virtual void TraverseAfter(const Sp<SwitchCase>& node) {}
    virtual bool TraverseBefore(const Sp<SwitchStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<SwitchStatement>& node) {}
    virtual bool TraverseBefore(const Sp<TaggedTemplateExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<TaggedTemplateExpression>& node) {}
    virtual bool TraverseBefore(const Sp<TemplateElement>& node) { return true; }
    virtual void TraverseAfter(const Sp<TemplateElement>& node) {}
    virtual bool TraverseBefore(const Sp<TemplateLiteral>& node) { return true; }
    virtual void TraverseAfter(const Sp<TemplateLiteral>& node) {}
    virtual bool TraverseBefore(const Sp<ThisExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<ThisExpression>& node) {}
    virtual bool TraverseBefore(const Sp<ThrowStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<ThrowStatement>& node) {}
    virtual bool TraverseBefore(const Sp<TryStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<TryStatement>& node) {}
    virtual bool TraverseBefore(const Sp<UnaryExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<UnaryExpression>& node) {}
    virtual bool TraverseBefore(const Sp<UpdateExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<UpdateExpression>& node) {}
    virtual bool TraverseBefore(const Sp<VariableDeclaration>& node) { return true; }
    virtual void TraverseAfter(const Sp<VariableDeclaration>& node) {}
    virtual bool TraverseBefore(const Sp<VariableDeclarator>& node) { return true; }
    virtual void TraverseAfter(const Sp<VariableDeclarator>& node) {}
    virtual bool TraverseBefore(const Sp<WhileStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<WhileStatement>& node) {}
    virtual bool TraverseBefore(const Sp<WithStatement>& node) { return true; }
    virtual void TraverseAfter(const Sp<WithStatement>& node) {}
    virtual bool TraverseBefore(const Sp<YieldExpression>& node) { return true; }
    virtual void TraverseAfter(const Sp<YieldExpression>& node) {}
    virtual bool TraverseBefore(const Sp<ArrowParameterPlaceHolder>& node) { return true; }
    virtual void TraverseAfter(const Sp<ArrowParameterPlaceHolder>& node) {}

    virtual ~AutoNodeTraverser() = default;

};


class NodeTraverser {
public:

    NodeTraverser() = default;
    
    void TraverseNode(const Sp<SyntaxNode>& node);

    virtual void Traverse(const Sp<ArrayExpression>& node) {}
    virtual void Traverse(const Sp<ArrayPattern>& node) {}
    virtual void Traverse(const Sp<ArrowFunctionExpression>& node) {}
    virtual void Traverse(const Sp<AssignmentExpression>& node) {}
    virtual void Traverse(const Sp<AssignmentPattern>& node) {}
    virtual void Traverse(const Sp<AwaitExpression>& node) {}
    virtual void Traverse(const Sp<BinaryExpression>& node) {}
    virtual void Traverse(const Sp<BlockStatement>& node) {}
    virtual void Traverse(const Sp<BreakStatement>& node) {}
    virtual void Traverse(const Sp<CallExpression>& node) {}
    virtual void Traverse(const Sp<CatchClause>& node) {}
    virtual void Traverse(const Sp<ClassBody>& node) {}
    virtual void Traverse(const Sp<ClassDeclaration>& node) {}
    virtual void Traverse(const Sp<ClassExpression>& node) {}
    virtual void Traverse(const Sp<ConditionalExpression>& node) {}
    virtual void Traverse(const Sp<ContinueStatement>& node) {}
    virtual void Traverse(const Sp<DebuggerStatement>& node) {}
    virtual void Traverse(const Sp<Directive>& node) {}
    virtual void Traverse(const Sp<DoWhileStatement>& node) {}
    virtual void Traverse(const Sp<EmptyStatement>& node) {}
    virtual void Traverse(const Sp<ExportAllDeclaration>& node) {}
    virtual void Traverse(const Sp<ExportDefaultDeclaration>& node) {}
    virtual void Traverse(const Sp<ExportNamedDeclaration>& node) {}
    virtual void Traverse(const Sp<ExportSpecifier>& node) {}
    virtual void Traverse(const Sp<ExpressionStatement>& node) {}
    virtual void Traverse(const Sp<ForInStatement>& node) {}
    virtual void Traverse(const Sp<ForOfStatement>& node) {}
    virtual void Traverse(const Sp<ForStatement>& node) {}
    virtual void Traverse(const Sp<FunctionDeclaration>& node) {}
    virtual void Traverse(const Sp<FunctionExpression>& node) {}
    virtual void Traverse(const Sp<Identifier>& node) {}
    virtual void Traverse(const Sp<IfStatement>& node) {}
    virtual void Traverse(const Sp<Import>& node) {}
    virtual void Traverse(const Sp<ImportDeclaration>& node) {}
    virtual void Traverse(const Sp<ImportDefaultSpecifier>& node) {}
    virtual void Traverse(const Sp<ImportNamespaceSpecifier>& node) {}
    virtual void Traverse(const Sp<ImportSpecifier>& node) {}
    virtual void Traverse(const Sp<LabeledStatement>& node) {}
    virtual void Traverse(const Sp<Literal>& node) {}
    virtual void Traverse(const Sp<MetaProperty>& node) {}
    virtual void Traverse(const Sp<MethodDefinition>& node) {}
    virtual void Traverse(const Sp<Module>& node) {}
    virtual void Traverse(const Sp<NewExpression>& node) {}
    virtual void Traverse(const Sp<ObjectExpression>& node) {}
    virtual void Traverse(const Sp<ObjectPattern>& node) {}
    virtual void Traverse(const Sp<Property>& node) {}
    virtual void Traverse(const Sp<RegexLiteral>& node) {}
    virtual void Traverse(const Sp<RestElement>& node) {}
    virtual void Traverse(const Sp<ReturnStatement>& node) {}
    virtual void Traverse(const Sp<Script>& node) {}
    virtual void Traverse(const Sp<SequenceExpression>& node) {}
    virtual void Traverse(const Sp<SpreadElement>& node) {}
    virtual void Traverse(const Sp<MemberExpression>& node) {}
    virtual void Traverse(const Sp<Super>& node) {}
    virtual void Traverse(const Sp<SwitchCase>& node) {}
    virtual void Traverse(const Sp<SwitchStatement>& node) {}
    virtual void Traverse(const Sp<TaggedTemplateExpression>& node) {}
    virtual void Traverse(const Sp<TemplateElement>& node) {}
    virtual void Traverse(const Sp<TemplateLiteral>& node) {}
    virtual void Traverse(const Sp<ThisExpression>& node) {}
    virtual void Traverse(const Sp<ThrowStatement>& node) {}
    virtual void Traverse(const Sp<TryStatement>& node) {}
    virtual void Traverse(const Sp<UnaryExpression>& node) {}
    virtual void Traverse(const Sp<UpdateExpression>& node) {}
    virtual void Traverse(const Sp<VariableDeclaration>& node) {}
    virtual void Traverse(const Sp<VariableDeclarator>& node) {}
    virtual void Traverse(const Sp<WhileStatement>& node) {}
    virtual void Traverse(const Sp<WithStatement>& node) {}
    virtual void Traverse(const Sp<YieldExpression>& node) {}
    virtual void Traverse(const Sp<ArrowParameterPlaceHolder>& node) {}

    virtual ~NodeTraverser() = default;

};
